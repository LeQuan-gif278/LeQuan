<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Magic Particles Morphing & Fireworks</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
    </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem;
    const particleCount = 8000;
    let isFireworksActive = false;
    const fireworks = [];

    // Cập nhật dòng chữ theo yêu cầu của bạn
    const messages = [
        "May mắn và thành công sẽ tới",
        "Điểm trong top đầu",
        "Giải cao trong tầm tay",
        "Thành quả xứng đáng"
    ];

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 300;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        const texture = new THREE.CanvasTexture(canvas);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount * 3; i++) positions[i] = (Math.random() - 0.5) * 1000;

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
            size: 2.2,
            map: texture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            color: 0x00d4ff
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize);
        
        runMessageSequence();
        animate();
    }

    async function runMessageSequence() {
        for (let i = 0; i < messages.length; i++) {
            morphToText(messages[i]);
            await new Promise(resolve => setTimeout(resolve, 4500));
        }
        isFireworksActive = true;
        startFireworksEngine();
    }

    function getTextImageData(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 200;
        ctx.font = "bold 80px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#ffffff";
        ctx.fillText(text, canvas.width / 2, canvas.height / 2);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const points = [];
        for (let y = 0; y < canvas.height; y += 2) {
            for (let x = 0; x < canvas.width; x += 2) {
                if (imageData[(y * canvas.width + x) * 4] > 128) {
                    points.push({
                        x: (x - canvas.width / 2) * 0.7,
                        y: -(y - canvas.height / 2) * 0.7
                    });
                }
            }
        }
        return points;
    }

    function morphToText(text) {
        const targetPoints = getTextImageData(text);
        const positions = particleSystem.geometry.attributes.position.array;

        for (let i = 0; i < particleCount; i++) {
            const target = targetPoints[i % targetPoints.length];
            const idx = i * 3;
            gsap.to(positions, {
                duration: 2.5,
                [idx]: target.x + (Math.random() - 0.5) * 3,
                [idx + 1]: target.y + (Math.random() - 0.5) * 3,
                [idx + 2]: (Math.random() - 0.5) * 10,
                ease: "expo.inOut",
                onUpdate: () => { particleSystem.geometry.attributes.position.needsUpdate = true; }
            });
        }
    }

    function createFirework() {
        const x = (Math.random() - 0.5) * 500;
        const y = (Math.random() - 0.2) * 300;
        const z = (Math.random() - 0.5) * 100;
        const color = new THREE.Color(hsl(${Math.random() * 360}, 100%, 70%));
        
        const count = 80;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const velocities = [];

        for (let i = 0; i < count; i++) {
            pos[i * 3] = x; pos[i * 3 + 1] = y; pos[i * 3 + 2] = z;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const speed = Math.random() * 1.5 + 0.5;
            velocities.push(new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta) * speed,
                Math.sin(phi) * Math.sin(theta) * speed,
                Math.cos(phi) * speed
            ));
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ size: 1.5, color: color, transparent: true, blending: THREE.AdditiveBlending, opacity: 1 });
        const mesh = new THREE.Points(geo, mat);
        scene.add(mesh);
        fireworks.push({ mesh, velocities, life: 1.0 });
    }

    function startFireworksEngine() {
        setInterval(() => {
            if (isFireworksActive) createFirework();
        }, 700);
    }

    function updateFireworks() {
        for (let i = fireworks.length - 1; i >= 0; i--) {
            const f = fireworks[i];
            const pos = f.mesh.geometry.attributes.position.array;
            f.life -= 0.012;
            f.mesh.material.opacity = f.life;
            
            for (let j = 0; j < f.velocities.length; j++) {
                pos[j * 3] += f.velocities[j].x;
                pos[j * 3 + 1] += f.velocities[j].y;
                pos[j * 3 + 2] += f.velocities[j].z;
                f.velocities[j].y -= 0.015;
            }
            f.mesh.geometry.attributes.position.needsUpdate = true;
            if (f.life <= 0) {
                scene.remove(f.mesh);
                fireworks.splice(i, 1);
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        
        particleSystem.rotation.y = Math.sin(time * 0.2) * 0.05;
        particleSystem.position.y = Math.sin(time * 0.5) * 3;

        updateFireworks();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
